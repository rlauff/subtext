// a text rewriting system based on scopes
// the interpreter moves over the file in a loop
// scopes:
//    a scope is a string surrounded by {}
//    a single whitespace after { and a before } is ignored when parsing
//    the first arm of a scope is of the form I : P : O ;
//    I is the input
//    P is the pattern
//    O is the output
//    Any whitespace surrounding : is ignored
//    Any whitespace before ; is ignored
//    Further arms have the form : P : O ;
//    We match pattern P against I and put capture groups into registers
//    If no match is found, we move to the next arm
//    If no match is found, the default result of a scope is the empty string
//    If a result is build, the entire scope is replaced by it in place
//    The interpreter resumes scanning after the result
//    capture groups are acessed via $1, $2 ...
//    capture groups from the parent scope are accessed by ^$1 etc, or ^^$1 etc for two levels up and so on
//    $0 is the full scope as a string

// functions:
//    a function is defined by def followed by a name and then a scope. Normally I = $0
//    a function is called by its name followed by () containing the input
//    $0 of a function is whatever was passed to it
//    a function will replace its entire input by its result
//    set def f { ^$0 : P : O } to replace the entire scope it was called from, potentially the whole file
//    the def expression is replaced by the empty string once read

special functions:
    there are build in functions which are always defined
    print() prints its arg to stdout. Replaced by empty string afterwards
    get_input() prints its arg to stdout and then waits for user input. Replaced by the user input
    error() prints its arg to stdout and exits the program
    exit() exits the program

/// sum_two_digits:
/// takes two digits and possible c (for carry), example: 35c.
/// Adds the two digits and adds one if c is present. If the result is bigger than 9, it gives the fitst digit and appends c for carry
def sum_two_digits {
    $0
// with carry
    : 00c                                               : 1     ;
    : (?:01|10)c                                        : 2     ;
    : (?:02|11|20)c                                     : 3     ;
    : (?:03|12|21|30)c                                  : 4     ;
    : (?:04|13|22|31|40)c                               : 5     ;
    : (?:05|14|23|32|41|50)c                            : 6     ;
    : (?:06|15|24|33|42|51|60)c                         : 7     ;
    : (?:07|16|25|34|43|52|61|70)c                      : 8     ;
    : (?:08|17|26|35|44|53|62|71|80)c                   : 9     ;
    : (?:09|18|27|36|45|54|63|72|81|90)c                : 0c    ;
    : (?:19|28|37|46|55|64|73|82|91)c                   : 1c    ;
    : (?:29|38|47|56|65|74|83|92)c                      : 2c    ;
    : (?:39|48|57|66|75|84|93)c                         : 3c    ;
    : (?:49|58|67|76|85|94)c                            : 4c    ;
    : (?:59|68|77|86|95)c                               : 5c    ;
    : (?:69|78|87|96)c                                  : 6c    ;
    : (?:79|88|97)c                                     : 7c    ;
    : (?:89|98)c                                        : 8c    ;
    : 99c                                               : 9c    ;
// without carry
    : 00                                                : 0     ;
    : 01|10                                             : 1     ;
    : 02|11|20                                          : 2     ;
    : 03|12|21|30                                       : 3     ;
    : 04|13|22|31|40                                    : 4     ;
    : 05|14|23|32|41|50                                 : 5     ;
    : 06|15|24|33|42|51|60                              : 6     ;
    : 07|16|25|34|43|52|61|70                           : 7     ;
    : 08|17|26|35|44|53|62|71|80                        : 8     ;
    : 09|18|27|36|45|54|63|72|81|90                     : 9     ;
    : 19|28|37|46|55|64|73|82|91                        : 0c    ;
    : 29|38|47|56|65|74|83|92                           : 1c    ;
    : 39|48|57|66|75|84|93                              : 2c    ;
    : 49|58|67|76|85|94                                 : 3c    ;
    : 59|68|77|86|95                                    : 4c    ;
    : 69|78|87|96                                       : 5c    ;
    : 79|88|97                                          : 6c    ;
    : 89|98                                             : 7c    ;
    : 99                                                : 8c    ;
// one or both digits missing with carry
    : (\d?)c                                : sum_two_digits($1 1)   ;   // whitespace after the register call $1 is ignored
// one or both digits missing without carry
    : (\d?)                                 : $1    ;
}

/// add_positive:
/// takes a sting with format Aa+Bb&c&<partial result>
/// A, B are a string of digits \d*, might be empty
/// a, b are the last digit of the summands if they are not empty
/// & is just a spacer
/// c is a flag for carry, might not be there
/// <partial result> is the part computed already
/// we extract the two last digits a,b
/// if both are there, we add them with carry, build the new string by adding the result to <partial result> and possibly adding the carry flag
/// then recurse
/// if one is empty and there is no carry, we can return the result by appending the other to the partial result
/// Note that this also works if both are empty
/// if there is still a carry we just replace the empty summand with 1 and recurse
def add_positive {
    $0
    :   (\d*)(\d)\+(\d*)(\d)&?(c?)&?(\d*) // Aa+Bb&c&R, happy path where neither summand is empty
        :   add_positive($1 +$3 &{ sum_two_digits(^$2 ^$4 ^$5) : (\d)(c?) : $2 &^$6 $1 }) ; // call sum_two_digits(abc) and place result in $1: the digit and $2: potential carry, then build the result string
    :   (:?\+(\d*)|(\d*)\x)&?(c?)&?(\d*) // one summand is empty
        :   { ^$2   : c : sum_positive(^$1 +1&&^$3) ;   // there is still a carry, replace the empty summand by 1
                    :   : $1 $3 }   ;                   // no more carry, can just write the result
    : : error() ;
}

def inc {
    $0
    :   :   add(1+$0)    ;
}








